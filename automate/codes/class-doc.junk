library(R6)
library(stringr)
library(glue)
library(fs)
library(readr)

VBADocParser <- R6Class("VBADocParser",
  public = list(
    folder = NULL,
    output_folder = "CSd",
    class_names = NULL,

    initialize = function(folder) {
      self$folder <- path_abs(folder)
      dir_create(self$output_folder)
      cli::cli_inform(glue("Parser initialized for folder: {self$folder}"))
    },

    parse = function() {
      cls_files <- dir_ls(self$folder, glob = "*.cls")
      self$class_names <- path_ext_remove(path_file(cls_files))

      for (idx in seq_along(cls_files)) {
        file <- cls_files[idx]
        class_name <- self$class_names[idx]
        cli::cli_inform(glue("Parsing: {path_file(file)}"))

        lines <- read_lines(file, locale = locale(encoding = "UTF-8"))
        blocks <- private$extract_doc_blocks(lines)

        if (length(blocks) > 0) {
          md <- private$build_markdown(class_name, blocks, self$class_names)
          write_file(md, path(self$output_folder, glue("{class_name}.md")))
          cli::cli_inform(glue("Written: {class_name}.md"))
        } else {
          cli::cli_alert_warning(glue("No valid @label: blocks found in {class_name}"))
        }
      }
    },

    detect_usages = function() {
      all_files <- dir_ls(self$folder, recurse = TRUE, regexp = "\\.(cls|bas)$")
      usage_map <- setNames(vector("list", length(self$class_names)), self$class_names)

      for (file in all_files) {
        content <- read_file(file)
        for (class_name in self$class_names) {
          iface <- paste0("I", class_name)
          if (str_detect(content, fixed(iface))) {
            usage_map[[class_name]] <- unique(c(usage_map[[class_name]], path_rel(file, self$folder)))
          }
        }
      }

      for (class_name in names(usage_map)) {
        md_path <- path(self$output_folder, glue("{class_name}.md"))
        if (file_exists(md_path)) {
          md <- read_lines(md_path)
          if (length(usage_map[[class_name]]) > 0) {
            usage_files <- sort(usage_map[[class_name]])
            section <- c(
              "",
              "<details>",
              glue("<summary>Used in ({length(usage_files)} file(s))</summary>"),
              "",
              glue("- [{basename(f)}]({f})", f = usage_files),
              "",
              "</details>"
            )
            md <- c(md, section)
          }
          write_lines(md, md_path)
          cli::cli_inform(glue("Updated usages for: {class_name}"))
        }
      }
    }
  ),

  private = list(
    extract_doc_blocks = function(lines) {
      result <- list()
      i <- 1
      n <- length(lines)

      while (i <= n) {
        line <- str_trim(lines[i])

        if (str_detect(line, "^'@label:")) {
          doc <- list()
          doc$label <- str_remove(line, "^'@label:\s*")
          i <- i + 1

          # capture doc block
          while (i <= n && str_detect(lines[i], "^'")) {
            l <- str_trim(lines[i])
            tag_match <- str_match(l, "^'@(\w+):?\s*(.*)$")
            if (!is.na(tag_match[1, 1])) {
              tag <- tag_match[1, 2]
              content <- tag_match[1, 3]
              if (tag == "description") {
                desc <- content
                i <- i + 1
                while (i <= n && str_detect(lines[i], "^'[^@]")) {
                  desc <- paste0(desc, "\n", str_remove(lines[i], "^'"))
                  i <- i + 1
                }
                doc[["description"]] <- desc
                next
              } else if (tag == "param") {
                if (is.null(doc$params)) doc$params <- list()
                doc$params <- append(doc$params, list(content))
              } else {
                doc[[tag]] <- content
              }
            }
            i <- i + 1
          }

          # expect the next line to be Sub or Property
          if (i <= n && str_detect(str_trim(lines[i]), "^(Public|Private)\s+(Sub|Function|Property)")) {
            doc$signature <- str_trim(lines[i])

            # only if @export
            if (!is.null(doc$export)) {
              result <- append(result, list(doc))
            }
          }
        } else {
          i <- i + 1
        }
      }
      return(result)
    },

    build_markdown = function(class_name, docs, class_names) {
      output <- c(glue("### {class_name}"), "")
      for (doc in docs) {
        subtitle <- doc[["sub-title"]]
        label <- doc[["label"]]
        sig <- doc[["signature"]]
        desc <- doc[["description"]]

        output <- c(output, glue("\n#### {subtitle}"))
        output <- c(output, "")
        output <- c(output, glue("**Signature:** `{sig}`"), "")

        if (!is.null(desc)) {
          desc <- private$resolve_links(desc, class_names)
          output <- c(output, glue("**Description:**\n\n{desc}"), "")
        }

        if (!is.null(doc$params)) {
          output <- c(output, "**Parameters:**")
          for (p in doc$params) {
            output <- c(output, glue("- {p}"))
          }
          output <- c(output, "")
        }
      }
      return(paste(output, collapse = "\n"))
    },

    resolve_links = function(text, class_names) {
      str_replace_all(text, "see::([A-Za-z0-9_]+)", function(m) {
        cls <- str_match(m, "see::([A-Za-z0-9_]+)")[,2]
        if (cls %in% class_names) {
          glue("[{cls}]({cls}.md)")
        } else {
          glue("{cls}")
        }
      })
    }
  )
)

# Example usage:
# parser <- VBADocParser$new("path/to/vba/classes")
# parser$parse()
# parser$detect_usages()

